<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audit des Flux Réseaux - ISO 27001</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 340px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.1);
        }

        .header {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #networkCanvas {
            width: 100%;
            height: 100%;
            cursor: grab;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.05) 0%, transparent 50%);
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 18px;
            cursor: pointer;
            font-weight: bold;
            margin: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            font-size: 11px;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #36d1dc, #5b86e5);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
        }

        .btn-success {
            background: linear-gradient(45deg, #4caf50, #8bc34a);
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: bold;
            color: #555;
            font-size: 12px;
        }

        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 6px 8px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 12px;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus, .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: white;
            margin: 1% auto;
            padding: 20px;
            border-radius: 15px;
            width: 95%;
            max-width: 700px;
            max-height: 95vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close:hover {
            color: #333;
        }

        .flow-item {
            background: white;
            margin: 6px 0;
            padding: 10px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .flow-item:hover {
            transform: translateX(3px);
        }

        .flow-item h4 {
            color: #667eea;
            margin-bottom: 3px;
            font-size: 13px;
        }

        .flow-item p {
            margin: 1px 0;
            font-size: 11px;
            color: #666;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 2px;
        }

        .stat-card p {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .protocol-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: bold;
            text-transform: uppercase;
            margin-right: 3px;
        }

        .protocol-tcp { background: #e3f2fd; color: #1976d2; }
        .protocol-udp { background: #f3e5f5; color: #7b1fa2; }
        .protocol-icmp { background: #fff3e0; color: #f57c00; }
        .protocol-http { background: #e8f5e8; color: #388e3c; }
        .protocol-https { background: #e1f5fe; color: #0277bd; }
        .protocol-ssh { background: #fce4ec; color: #c2185b; }
        .protocol-ftp { background: #f1f8e9; color: #689f38; }
        .protocol-smtp { background: #fff8e1; color: #ffa000; }
        .protocol-dns { background: #f3e5f5; color: #7b1fa2; }

        .risk-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }

        .risk-low { background: #4caf50; }
        .risk-medium { background: #ff9800; }
        .risk-high { background: #f44336; }
        .risk-critical { background: #d32f2f; }

        #flowList {
            max-height: 280px;
            overflow-y: auto;
        }

        .section-title {
            color: #667eea;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 3px;
            border-bottom: 2px solid #e1e8ed;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .three-column {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .view-selector {
            background: white;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .active-view {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .node-context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2000;
            min-width: 180px;
            display: none;
        }

        .node-context-menu .menu-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .node-context-menu .menu-item:hover {
            background: #f5f5f5;
        }

        .node-context-menu .menu-item:last-child {
            border-bottom: none;
        }

        .node-context-menu .menu-item .icon {
            font-size: 14px;
            width: 16px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 250px;
            }
            
            .modal-content {
                width: 95%;
                margin: 2% auto;
                padding: 15px;
            }
            
            .two-column, .three-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1 style="color: #667eea; margin-bottom: 12px; text-align: center; font-size: 16px;">
                <strong>Audit Flux Réseaux ISO 27001</strong>
            </h1>

            <div class="stats">
                <div class="stat-card">
                    <h3 id="totalFlows">0</h3>
                    <p>Total Flux</p>
                </div>
                <div class="stat-card">
                    <h3 id="criticalFlows">0</h3>
                    <p>Critiques</p>
                </div>
                <div class="stat-card">
                    <h3 id="totalViews">1</h3>
                    <p>Vues</p>
                </div>
            </div>

            <div class="view-selector">
                <div class="section-title">Vue Active</div>
                <select id="cartographyType" onchange="changeCartographyType()" style="margin-bottom: 6px;">
                    <option value="default">Vue par défaut</option>
                </select>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-bottom: 4px;">
                    <button class="btn btn-secondary" onclick="openNewViewModal()">+ Vue</button>
                    <button class="btn btn-secondary" onclick="duplicateCurrentView()">📋 Dupli</button>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                    <button class="btn btn-secondary" onclick="editCurrentView()">✏️ Edit</button>
                    <button class="btn btn-danger" onclick="deleteCurrentView()">🗑️ Del</button>
                </div>
            </div>

            <div class="section-title">Actions</div>
            <div style="display: flex; flex-wrap: wrap;">
                <button class="btn" onclick="openFlowModal()">+ Flux</button>
                <button class="btn btn-secondary" onclick="createDefaultCartography()">📋 Exemple</button>
                <button class="btn btn-secondary" onclick="openConfigModal()">⚙️ Config</button>
                <button class="btn btn-success" onclick="generateAuditReport()">📋 Audit PDF</button>
                <button class="btn btn-secondary" onclick="generateTechnicalReport()">📊 Tech PDF</button>
                <button class="btn btn-secondary" onclick="exportDrawIO()">📐 Draw.io</button>
                <button class="btn btn-secondary" onclick="exportData()">💾 Export</button>
                <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">📁 Import</button>
                <input type="file" id="importFile" style="display: none;" onchange="importData()" accept=".json">
                <button class="btn btn-danger" onclick="clearAllFlows()">🗑️ Reset</button>
            </div>

            <div class="section-title">Flux de la Vue Courante</div>
            <div id="flowList"></div>
        </div>

        <div class="main-content">
            <div class="header">
                <div>
                    <h2 style="color: #667eea; font-size: 16px;" id="viewTitle">Cartographie des Flux Réseau</h2>
                    <p style="color: #666; font-size: 12px; margin-top: 2px;" id="viewDescription">Vue par défaut</p>
                </div>
                <div>
                    <button class="btn btn-secondary" onclick="resetView()">🏠 Reset</button>
                    <button class="btn btn-secondary" onclick="captureView()">📷 Capture</button>
                    <span style="color: #666; margin-left: 10px; font-size: 12px;">Zoom: <span id="zoomLevel">100%</span></span>
                </div>
            </div>
            <div class="canvas-container">
                <svg id="networkCanvas"></svg>
            </div>
        </div>
    </div>

    <!-- Menu contextuel pour les noeuds -->
    <div id="nodeContextMenu" class="node-context-menu">
        <div class="menu-item" onclick="createFlowFromNode()">
            <span class="icon">➕</span>
            <span>Créer flux depuis ce nœud</span>
        </div>
        <div class="menu-item" onclick="createFlowToNode()">
            <span class="icon">⬅️</span>
            <span>Créer flux vers ce nœud</span>
        </div>
        <div class="menu-item" onclick="showNodeFlows()">
            <span class="icon">🔍</span>
            <span>Voir tous les flux</span>
        </div>
        <div class="menu-item" onclick="filterByNode()">
            <span class="icon">🔽</span>
            <span>Filtrer par ce nœud</span>
        </div>
    </div>

    <!-- Modal pour ajouter un flux -->
    <div id="flowModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeFlowModal()">&times;</span>
            <h2 style="color: #667eea; margin-bottom: 15px; font-size: 18px;">Nouveau Flux Réseau</h2>
            
            <div class="input-group">
                <label for="flowName">Nom du Flux:</label>
                <input type="text" id="flowName" placeholder="Ex: Base de données vers serveur web">
            </div>

            <div class="input-group">
                <label for="flowView">Vue de destination:</label>
                <select id="flowView">
                </select>
            </div>
            
            <div class="two-column">
                <div class="input-group">
                    <label for="protocol">Protocole:</label>
                    <select id="protocol" onchange="updatePortFromProtocol()">
                    </select>
                </div>
                
                <div class="input-group">
                    <label for="riskLevel">Niveau de Risque:</label>
                    <select id="riskLevel">
                    </select>
                </div>
            </div>
            
            <div class="two-column">
                <div class="input-group">
                    <label for="sourceIP">IP Source:</label>
                    <input type="text" id="sourceIP" placeholder="192.168.1.10">
                </div>
                
                <div class="input-group">
                    <label for="sourcePort">Port Source:</label>
                    <input type="number" id="sourcePort" placeholder="Auto" min="1" max="65535">
                </div>
            </div>
            
            <div class="two-column">
                <div class="input-group">
                    <label for="destIP">IP Destination:</label>
                    <input type="text" id="destIP" placeholder="192.168.1.20">
                </div>
                
                <div class="input-group">
                    <label for="destPort">Port Destination:</label>
                    <input type="number" id="destPort" placeholder="Auto" min="1" max="65535">
                </div>
            </div>
            
            <div class="input-group">
                <label for="description">Description:</label>
                <input type="text" id="description" placeholder="Description du flux réseau">
            </div>
            
            <div class="input-group">
                <label for="businessJustification">Justification Métier:</label>
                <input type="text" id="businessJustification" placeholder="Nécessaire pour...">
            </div>
            
            <div id="variantSection" style="display: none;">
                <div class="section-title">Type de Modification</div>
                <div class="input-group">
                    <label for="variantType">Action sur la vue par défaut:</label>
                    <select id="variantType" onchange="toggleVariantOptions()">
                        <option value="">Aucune modification</option>
                        <option value="replacement">Remplacer un flux par défaut</option>
                        <option value="addition">Ajouter un flux spécifique</option>
                        <option value="cancellation">Annuler un flux par défaut</option>
                    </select>
                </div>
                
                <div id="replacementFields" style="display: none;">
                    <div class="input-group">
                        <label for="replacedFlowId">Flux à remplacer:</label>
                        <select id="replacedFlowId">
                        </select>
                    </div>
                </div>
                
                <div id="cancellationFields" style="display: none;">
                    <div class="input-group">
                        <label for="cancelledFlowId">Flux à annuler:</label>
                        <select id="cancelledFlowId">
                        </select>
                    </div>
                </div>
                
                <div id="justificationFields" style="display: none;">
                    <div class="input-group">
                        <label for="variantJustification">Justification:</label>
                        <textarea id="variantJustification" rows="2" placeholder="Pourquoi cette modification est-elle nécessaire..."></textarea>
                    </div>
                </div>
            </div>
            
            <button class="btn" onclick="addFlow()" style="width: 100%; margin-top: 10px;">Ajouter le Flux</button>
        </div>
    </div>

    <!-- Modal pour nouvelle vue -->
    <div id="newViewModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeNewViewModal()">&times;</span>
            <h2 style="color: #667eea; margin-bottom: 15px;">Vue Personnalisée</h2>
            
            <div class="input-group">
                <label for="viewTitle">Titre de la Vue:</label>
                <input type="text" id="viewTitleInput" placeholder="Ex: Serveur Web DMZ">
            </div>
            
            <div class="input-group">
                <label for="viewDescription">Description:</label>
                <input type="text" id="viewDescriptionInput" placeholder="Description de cette vue">
            </div>
            
            <div class="input-group">
                <label for="viewType">Type de Vue:</label>
                <select id="viewType">
                    <option value="vertical">Vue verticale (source→destination)</option>
                    <option value="server">Vue par serveur (hub central)</option>
                    <option value="network">Vue par réseau</option>
                    <option value="service">Vue par service</option>
                </select>
            </div>
            
            <button class="btn" onclick="addNewView()" style="width: 100%; margin-top: 10px;">Créer la Vue</button>
        </div>
    </div>

    <!-- Modal pour configuration -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeConfigModal()">&times;</span>
            <h2 style="color: #667eea; margin-bottom: 15px;">Configuration JSON</h2>
            
            <div class="section-title">Protocoles</div>
            <div class="input-group">
                <textarea id="protocolsConfig" rows="4" placeholder="Format JSON" style="font-family: monospace; font-size: 11px;"></textarea>
            </div>
            
            <div class="section-title">Niveaux de Risque</div>
            <div class="input-group">
                <textarea id="riskLevelsConfig" rows="3" placeholder="Format JSON" style="font-family: monospace; font-size: 11px;"></textarea>
            </div>
            
            <div class="section-title">Ports Communs</div>
            <div class="input-group">
                <textarea id="portsConfig" rows="5" placeholder="Format JSON" style="font-family: monospace; font-size: 11px;"></textarea>
            </div>
            
            <div style="margin-top: 15px;">
                <button class="btn" onclick="saveConfiguration()">Sauvegarder</button>
                <button class="btn btn-secondary" onclick="resetConfiguration()">Réinitialiser</button>
            </div>
        </div>
    </div>

    <!-- Modal d'audit -->
    <div id="auditModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeAuditModal()">&times;</span>
            <h2 style="color: #667eea; margin-bottom: 15px;">Rapport d'Audit ISO 27001</h2>
            
            <div class="two-column">
                <div class="input-group">
                    <label for="companyName">Nom de l'Entreprise:</label>
                    <input type="text" id="companyName" placeholder="ACME Corp">
                </div>
                
                <div class="input-group">
                    <label for="auditorName">Nom de l'Auditeur:</label>
                    <input type="text" id="auditorName" placeholder="Jean Dupont">
                </div>
            </div>
            
            <div class="two-column">
                <div class="input-group">
                    <label for="auditDate">Date d'Audit:</label>
                    <input type="date" id="auditDate">
                </div>
                
                <div class="input-group">
                    <label for="auditScope">Périmètre:</label>
                    <input type="text" id="auditScope" placeholder="Infrastructure réseau">
                </div>
            </div>
            
            <div class="input-group">
                <label for="auditObjective">Objectif de l'Audit:</label>
                <textarea id="auditObjective" rows="3" placeholder="Vérifier la conformité des flux réseau aux exigences ISO 27001..."></textarea>
            </div>
            
            <div class="input-group">
                <label for="auditConclusion">Conclusion:</label>
                <textarea id="auditConclusion" rows="3" placeholder="L'audit révèle que..."></textarea>
            </div>
            
            <button class="btn" onclick="generateFullAuditReport()" style="width: 100%; margin-top: 10px;">Générer Rapport d'Audit</button>
        </div>
    </div>

    <script>
        // Structure de données principale
        let appData = {
            networkFlows: [],
            customViews: [],
            configData: {
                protocols: [
                    { value: 'TCP', label: 'TCP' },
                    { value: 'UDP', label: 'UDP' },
                    { value: 'HTTP', label: 'HTTP' },
                    { value: 'HTTPS', label: 'HTTPS' },
                    { value: 'ICMP', label: 'ICMP' },
                    { value: 'SSH', label: 'SSH' },
                    { value: 'FTP', label: 'FTP' },
                    { value: 'SMTP', label: 'SMTP' },
                    { value: 'DNS', label: 'DNS' },
                    { value: 'SNMP', label: 'SNMP' },
                    { value: 'LDAP', label: 'LDAP' }
                ],
                riskLevels: [
                    { value: 'low', label: 'Faible' },
                    { value: 'medium', label: 'Moyen' },
                    { value: 'high', label: 'Élevé' },
                    { value: 'critical', label: 'Critique' }
                ],
                commonPorts: {
                    'HTTP': 80,
                    'HTTPS': 443,
                    'SSH': 22,
                    'FTP': 21,
                    'SMTP': 25,
                    'DNS': 53,
                    'SNMP': 161,
                    'LDAP': 389,
                    'TCP': 8080,
                    'UDP': 8080
                }
            },
            auditInfo: {
                companyName: '',
                auditorName: '',
                auditDate: '',
                auditScope: '',
                auditObjective: '',
                auditConclusion: ''
            },
            metadata: {
                version: '2.1',
                created: new Date().toISOString(),
                lastModified: new Date().toISOString()
            }
        };

        let svgElement;
        let currentZoom = 1;
        let currentPanX = 0;
        let currentPanY = 0;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let currentViewId = 'default';
        let editingViewId = null;
        let selectedNodeIP = null;
        let selectedNodeType = null;

        function showNodeContextMenu(event, node, type) {
            selectedNodeIP = node.ip;
            selectedNodeType = type;
            
            const menu = document.getElementById('nodeContextMenu');
            menu.style.display = 'block';
            menu.style.left = event.pageX + 'px';
            menu.style.top = event.pageY + 'px';
            
            // Fermer le menu si on clique ailleurs
            setTimeout(() => {
                document.addEventListener('click', hideNodeContextMenu, { once: true });
            }, 10);
        }

        function hideNodeContextMenu() {
            document.getElementById('nodeContextMenu').style.display = 'none';
        }

        function createFlowFromNode() {
            hideNodeContextMenu();
            document.getElementById('sourceIP').value = selectedNodeIP;
            resetModalToAddMode();
            openFlowModal();
        }

        function createFlowToNode() {
            hideNodeContextMenu();
            document.getElementById('destIP').value = selectedNodeIP;
            resetModalToAddMode();
            openFlowModal();
        }

        function showNodeFlows() {
            hideNodeContextMenu();
            const nodeFlows = getCurrentFlows().filter(flow => 
                flow.sourceIP === selectedNodeIP || flow.destIP === selectedNodeIP
            );
            
            if (nodeFlows.length === 0) {
                alert(`Aucun flux trouvé pour ${selectedNodeIP}`);
                return;
            }

            let message = `Flux pour ${selectedNodeIP} :\n\n`;
            nodeFlows.forEach((flow, index) => {
                const direction = flow.sourceIP === selectedNodeIP ? '→' : '←';
                const otherIP = flow.sourceIP === selectedNodeIP ? flow.destIP : flow.sourceIP;
                message += `${index + 1}. ${flow.name}\n   ${direction} ${otherIP} (${flow.protocol}:${flow.destPort || 'Auto'})\n   Risque: ${getRiskLabel(flow.riskLevel)}\n\n`;
            });
            
            alert(message);
        }

        function filterByNode() {
            hideNodeContextMenu();
            // Mettre en évidence les flux associés à ce nœud
            const flowList = document.getElementById('flowList');
            const flowItems = flowList.querySelectorAll('.flow-item');
            
            flowItems.forEach(item => {
                const flowText = item.textContent.toLowerCase();
                if (flowText.includes(selectedNodeIP.toLowerCase())) {
                    item.style.background = '#e3f2fd';
                    item.style.borderLeft = '4px solid #2196f3';
                } else {
                    item.style.background = '';
                    item.style.borderLeft = '4px solid #667eea';
                }
            });
            
            // Scroll vers la liste des flux
            flowList.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function init() {
            svgElement = document.getElementById('networkCanvas');
            setupSVGInteractions();
            document.getElementById('auditDate').value = new Date().toISOString().split('T')[0];
            populateDropdowns();
            updateDisplay();
            loadFromStorage();
        }

        function populateDropdowns() {
            const protocolSelect = document.getElementById('protocol');
            const riskSelect = document.getElementById('riskLevel');
            const flowViewSelect = document.getElementById('flowView');
            
            // Protocoles
            protocolSelect.innerHTML = '';
            appData.configData.protocols.forEach(protocol => {
                const option = document.createElement('option');
                option.value = protocol.value;
                option.textContent = protocol.label;
                protocolSelect.appendChild(option);
            });
            
            // Niveaux de risque
            riskSelect.innerHTML = '';
            appData.configData.riskLevels.forEach(risk => {
                const option = document.createElement('option');
                option.value = risk.value;
                option.textContent = risk.label;
                riskSelect.appendChild(option);
            });

            // Vues pour les flux
            updateFlowViewSelector();
        }

        function updateFlowViewSelector() {
            const flowViewSelect = document.getElementById('flowView');
            flowViewSelect.innerHTML = '<option value="default">Vue par défaut</option>';
            
            appData.customViews.forEach(view => {
                const option = document.createElement('option');
                option.value = view.id;
                option.textContent = view.title;
                flowViewSelect.appendChild(option);
            });

            flowViewSelect.value = currentViewId;
            flowViewSelect.addEventListener('change', toggleVariantFields);
        }

        function updatePortFromProtocol() {
            const protocol = document.getElementById('protocol').value;
            const destPortInput = document.getElementById('destPort');
            
            if (appData.configData.commonPorts[protocol]) {
                destPortInput.value = appData.configData.commonPorts[protocol];
                destPortInput.placeholder = appData.configData.commonPorts[protocol];
            }
        }

        function setupSVGInteractions() {
            svgElement.addEventListener('mousedown', startDrag);
            svgElement.addEventListener('mousemove', drag);
            svgElement.addEventListener('mouseup', stopDrag);
            svgElement.addEventListener('wheel', zoom);
            
            svgElement.addEventListener('touchstart', handleTouch);
            svgElement.addEventListener('touchmove', handleTouch);
            svgElement.addEventListener('touchend', handleTouch);
        }

        function startDrag(e) {
            isDragging = true;
            dragStart.x = e.clientX - currentPanX;
            dragStart.y = e.clientY - currentPanY;
            svgElement.style.cursor = 'grabbing';
        }

        function drag(e) {
            if (!isDragging) return;
            e.preventDefault();
            currentPanX = e.clientX - dragStart.x;
            currentPanY = e.clientY - dragStart.y;
            updateSVGTransform();
        }

        function stopDrag() {
            isDragging = false;
            svgElement.style.cursor = 'grab';
        }

        function zoom(e) {
            e.preventDefault();
            const rect = svgElement.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = Math.max(0.1, Math.min(5, currentZoom * zoomFactor));
            
            const zoomRatio = newZoom / currentZoom;
            currentPanX = x - (x - currentPanX) * zoomRatio;
            currentPanY = y - (y - currentPanY) * zoomRatio;
            currentZoom = newZoom;
            
            updateSVGTransform();
            document.getElementById('zoomLevel').textContent = Math.round(currentZoom * 100) + '%';
        }

        function updateSVGTransform() {
            const transform = `translate(${currentPanX}px, ${currentPanY}px) scale(${currentZoom})`;
            svgElement.style.transform = transform;
        }

        function resetView() {
            currentZoom = 1;
            currentPanX = 0;
            currentPanY = 0;
            updateSVGTransform();
            document.getElementById('zoomLevel').textContent = '100%';
        }

        function captureView() {
            html2canvas(svgElement).then(canvas => {
                const link = document.createElement('a');
                link.download = `cartographie-${getCurrentView().title || 'default'}.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
        }

        function handleTouch(e) {
            e.preventDefault();
            if (e.type === 'touchstart') {
                const touch = e.touches[0];
                startDrag({ clientX: touch.clientX, clientY: touch.clientY });
            } else if (e.type === 'touchmove') {
                const touch = e.touches[0];
                drag({ clientX: touch.clientX, clientY: touch.clientY, preventDefault: () => {} });
            } else if (e.type === 'touchend') {
                stopDrag();
            }
        }

        // Gestion des modales
        function openFlowModal() {
            updateFlowViewSelector();
            toggleVariantFields();
            document.getElementById('flowModal').style.display = 'block';
        }

        function closeFlowModal() {
            document.getElementById('flowModal').style.display = 'none';
            resetModalToAddMode();
            clearModalInputs();
        }

        function resetModalToAddMode() {
            const addButton = document.querySelector('#flowModal button[onclick*="Flow"]');
            if (addButton) {
                addButton.textContent = 'Ajouter le Flux';
                addButton.onclick = function() { addFlow(); };
            }
        }

        function openNewViewModal() {
            editingViewId = null;
            document.getElementById('viewTitleInput').value = '';
            document.getElementById('viewDescriptionInput').value = '';
            document.getElementById('viewType').selectedIndex = 0;
            document.getElementById('newViewModal').style.display = 'block';
        }

        function closeNewViewModal() {
            document.getElementById('newViewModal').style.display = 'none';
        }

        function openConfigModal() {
            document.getElementById('configModal').style.display = 'block';
            document.getElementById('protocolsConfig').value = JSON.stringify(appData.configData.protocols, null, 2);
            document.getElementById('riskLevelsConfig').value = JSON.stringify(appData.configData.riskLevels, null, 2);
            document.getElementById('portsConfig').value = JSON.stringify(appData.configData.commonPorts, null, 2);
        }

        function closeConfigModal() {
            document.getElementById('configModal').style.display = 'none';
        }

        function openAuditModal() {
            const audit = appData.auditInfo;
            document.getElementById('companyName').value = audit.companyName;
            document.getElementById('auditorName').value = audit.auditorName;
            document.getElementById('auditDate').value = audit.auditDate || new Date().toISOString().split('T')[0];
            document.getElementById('auditScope').value = audit.auditScope;
            document.getElementById('auditObjective').value = audit.auditObjective;
            document.getElementById('auditConclusion').value = audit.auditConclusion;
            document.getElementById('auditModal').style.display = 'block';
        }

        function closeAuditModal() {
            document.getElementById('auditModal').style.display = 'none';
        }

        function toggleVariantFields() {
            const flowViewId = document.getElementById('flowView').value;
            const variantSection = document.getElementById('variantSection');
            
            // Montrer la section variant seulement si ce n'est pas la vue par défaut
            if (flowViewId === 'default') {
                variantSection.style.display = 'none';
            } else {
                variantSection.style.display = 'block';
                updateDefaultFlowSelectors();
            }
        }

        function toggleVariantOptions() {
            const variantType = document.getElementById('variantType').value;
            
            document.getElementById('replacementFields').style.display = variantType === 'replacement' ? 'block' : 'none';
            document.getElementById('cancellationFields').style.display = variantType === 'cancellation' ? 'block' : 'none';
            document.getElementById('justificationFields').style.display = variantType ? 'block' : 'none';
        }

        function updateDefaultFlowSelectors() {
            const defaultFlows = appData.networkFlows.filter(f => f.viewId === 'default');
            
            const replacedSelect = document.getElementById('replacedFlowId');
            const cancelledSelect = document.getElementById('cancelledFlowId');
            
            // Vider les sélecteurs
            replacedSelect.innerHTML = '<option value="">Sélectionner un flux</option>';
            cancelledSelect.innerHTML = '<option value="">Sélectionner un flux</option>';
            
            // Remplir avec les flux par défaut
            defaultFlows.forEach(flow => {
                const option1 = document.createElement('option');
                option1.value = flow.id;
                option1.textContent = `${flow.name} (${flow.protocol})`;
                replacedSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = flow.id;
                option2.textContent = `${flow.name} (${flow.protocol})`;
                cancelledSelect.appendChild(option2);
            });
        }

        function clearModalInputs() {
            document.getElementById('flowName').value = '';
            document.getElementById('protocol').selectedIndex = 0;
            document.getElementById('sourceIP').value = '';
            document.getElementById('sourcePort').value = '';
            document.getElementById('destIP').value = '';
            document.getElementById('destPort').value = '';
            document.getElementById('riskLevel').selectedIndex = 0;
            document.getElementById('description').value = '';
            document.getElementById('businessJustification').value = '';
            document.getElementById('variantType').selectedIndex = 0;
            document.getElementById('variantJustification').value = '';
            document.getElementById('replacedFlowId').selectedIndex = 0;
            document.getElementById('cancelledFlowId').selectedIndex = 0;
            toggleVariantFields();
            toggleVariantOptions();
        }

        // Gestion des flux
        function addFlow() {
            const viewId = document.getElementById('flowView').value;
            const variantType = document.getElementById('variantType').value;
            
            const flow = {
                id: Date.now(),
                viewId: viewId,
                name: document.getElementById('flowName').value,
                protocol: document.getElementById('protocol').value,
                sourceIP: document.getElementById('sourceIP').value,
                sourcePort: document.getElementById('sourcePort').value,
                destIP: document.getElementById('destIP').value,
                destPort: document.getElementById('destPort').value,
                riskLevel: document.getElementById('riskLevel').value,
                description: document.getElementById('description').value,
                businessJustification: document.getElementById('businessJustification').value,
                timestamp: new Date().toISOString()
            };

            // Ajouter les informations de variant si nécessaire
            if (viewId !== 'default' && variantType) {
                flow.variantType = variantType;
                flow.variantJustification = document.getElementById('variantJustification').value;
                
                if (variantType === 'replacement') {
                    flow.replacedFlowId = document.getElementById('replacedFlowId').value;
                } else if (variantType === 'cancellation') {
                    flow.cancelledFlowId = document.getElementById('cancelledFlowId').value;
                }
            }

            // Validations
            if (variantType === 'cancellation') {
                if (!flow.cancelledFlowId) {
                    alert('Veuillez sélectionner le flux à annuler.');
                    return;
                }
                if (!flow.variantJustification.trim()) {
                    alert('Veuillez justifier l\'annulation de ce flux.');
                    return;
                }
            } else {
                if (!flow.name || !flow.sourceIP || !flow.destIP) {
                    alert('Veuillez remplir au minimum le nom, l\'IP source et l\'IP destination.');
                    return;
                }
            }
            
            if (variantType === 'replacement' && !flow.replacedFlowId) {
                alert('Veuillez sélectionner le flux à remplacer.');
                return;
            }
            
            if (variantType && !flow.variantJustification.trim()) {
                alert('Veuillez justifier cette modification.');
                return;
            }

            appData.networkFlows.push(flow);
            appData.metadata.lastModified = new Date().toISOString();
            closeFlowModal();
            updateDisplay();
            saveToStorage();
        }

        function editFlow(id) {
            const flow = appData.networkFlows.find(f => f.id == id);
            if (!flow) {
                alert('Flux introuvable');
                return;
            }
            
            // Remplir le modal avec les données existantes
            document.getElementById('flowName').value = flow.name;
            document.getElementById('protocol').value = flow.protocol;
            document.getElementById('sourceIP').value = flow.sourceIP;
            document.getElementById('sourcePort').value = flow.sourcePort || '';
            document.getElementById('destIP').value = flow.destIP;
            document.getElementById('destPort').value = flow.destPort || '';
            document.getElementById('riskLevel').value = flow.riskLevel;
            document.getElementById('description').value = flow.description || '';
            document.getElementById('businessJustification').value = flow.businessJustification || '';
            document.getElementById('flowView').value = flow.viewId;
            
            // Gérer les variants
            if (flow.variantType) {
                document.getElementById('variantType').value = flow.variantType;
                document.getElementById('variantJustification').value = flow.variantJustification || '';
                if (flow.replacedFlowId) {
                    document.getElementById('replacedFlowId').value = flow.replacedFlowId;
                }
                if (flow.cancelledFlowId) {
                    document.getElementById('cancelledFlowId').value = flow.cancelledFlowId;
                }
            }
            
            toggleVariantFields();
            toggleVariantOptions();
            
            // Modifier le bouton pour l'édition
            const addButton = document.querySelector('#flowModal button[onclick="addFlow()"]');
            addButton.textContent = 'Modifier le Flux';
            addButton.onclick = function() { updateFlow(id); };
            
            openFlowModal();
        }

        function updateFlow(id) {
            const flow = appData.networkFlows.find(f => f.id == id);
            if (!flow) {
                alert('Flux introuvable');
                return;
            }

            const viewId = document.getElementById('flowView').value;
            const variantType = document.getElementById('variantType').value;
            
            // Mise à jour des données
            flow.viewId = viewId;
            flow.name = document.getElementById('flowName').value;
            flow.protocol = document.getElementById('protocol').value;
            flow.sourceIP = document.getElementById('sourceIP').value;
            flow.sourcePort = document.getElementById('sourcePort').value;
            flow.destIP = document.getElementById('destIP').value;
            flow.destPort = document.getElementById('destPort').value;
            flow.riskLevel = document.getElementById('riskLevel').value;
            flow.description = document.getElementById('description').value;
            flow.businessJustification = document.getElementById('businessJustification').value;

            // Ajouter les informations de variant si nécessaire
            if (viewId !== 'default' && variantType) {
                flow.variantType = variantType;
                flow.variantJustification = document.getElementById('variantJustification').value;
                
                if (variantType === 'replacement') {
                    flow.replacedFlowId = document.getElementById('replacedFlowId').value;
                } else if (variantType === 'cancellation') {
                    flow.cancelledFlowId = document.getElementById('cancelledFlowId').value;
                }
            } else {
                // Nettoyer les propriétés variant si pas nécessaire
                delete flow.variantType;
                delete flow.variantJustification;
                delete flow.replacedFlowId;
                delete flow.cancelledFlowId;
            }

            // Validations (même logique que addFlow)
            if (variantType === 'cancellation') {
                if (!flow.cancelledFlowId) {
                    alert('Veuillez sélectionner le flux à annuler.');
                    return;
                }
                if (!flow.variantJustification.trim()) {
                    alert('Veuillez justifier l\'annulation de ce flux.');
                    return;
                }
            } else {
                if (!flow.name || !flow.sourceIP || !flow.destIP) {
                    alert('Veuillez remplir au minimum le nom, l\'IP source et l\'IP destination.');
                    return;
                }
            }
            
            if (variantType === 'replacement' && !flow.replacedFlowId) {
                alert('Veuillez sélectionner le flux à remplacer.');
                return;
            }
            
            if (variantType && !flow.variantJustification.trim()) {
                alert('Veuillez justifier cette modification.');
                return;
            }

            appData.metadata.lastModified = new Date().toISOString();
            closeFlowModal();
            updateDisplay();
            saveToStorage();
        }

        function deleteFlow(id) {
            if (confirm('Supprimer ce flux ?')) {
                appData.networkFlows = appData.networkFlows.filter(flow => flow.id !== id);
                appData.metadata.lastModified = new Date().toISOString();
                updateDisplay();
                saveToStorage();
            }
        }

        function clearAllFlows() {
            if (confirm('Supprimer tous les flux de toutes les vues ?')) {
                appData.networkFlows = [];
                appData.metadata.lastModified = new Date().toISOString();
                updateDisplay();
                saveToStorage();
            }
        }

        // Gestion des vues
        function addNewView() {
            const title = document.getElementById('viewTitleInput').value;
            const description = document.getElementById('viewDescriptionInput').value;
            const type = document.getElementById('viewType').value;

            if (!title) {
                alert('Veuillez saisir un titre pour la vue.');
                return;
            }

            if (editingViewId) {
                // Mode édition
                const view = appData.customViews.find(v => v.id === editingViewId);
                if (view) {
                    view.title = title;
                    view.description = description;
                    view.type = type;
                }
            } else {
                // Mode création
                const view = {
                    id: Date.now().toString(),
                    title: title,
                    description: description,
                    type: type,
                    created: new Date().toISOString()
                };
                appData.customViews.push(view);
            }

            appData.metadata.lastModified = new Date().toISOString();
            updateViewSelector();
            closeNewViewModal();
            saveToStorage();
        }

        function duplicateCurrentView() {
            if (currentViewId === 'default') {
                alert('Impossible de dupliquer la vue par défaut');
                return;
            }

            const sourceView = appData.customViews.find(v => v.id === currentViewId);
            if (!sourceView) {
                alert('Vue source introuvable');
                return;
            }

            const timestamp = Date.now();
            const duplicatedView = {
                id: timestamp.toString(),
                title: `${sourceView.title} (Copie)`,
                description: `Copie de: ${sourceView.description}`,
                type: sourceView.type,
                created: new Date().toISOString(),
                duplicatedFrom: sourceView.id
            };

            appData.customViews.push(duplicatedView);

            // Dupliquer les flux de la vue
            const sourceFlows = appData.networkFlows.filter(f => f.viewId === currentViewId);
            sourceFlows.forEach((flow, index) => {
                const duplicatedFlow = {
                    ...flow,
                    id: timestamp + index + 1,
                    viewId: duplicatedView.id,
                    timestamp: new Date().toISOString()
                };
                appData.networkFlows.push(duplicatedFlow);
            });

            appData.metadata.lastModified = new Date().toISOString();
            updateViewSelector();
            
            // Basculer vers la vue dupliquée
            currentViewId = duplicatedView.id;
            document.getElementById('cartographyType').value = currentViewId;
            updateDisplay();
            saveToStorage();
            
            alert(`Vue "${duplicatedView.title}" créée avec ${sourceFlows.length} flux dupliqués`);
        }

        function editCurrentView() {
            if (currentViewId === 'default') {
                alert('Impossible d\'éditer la vue par défaut');
                return;
            }

            const view = appData.customViews.find(v => v.id === currentViewId);
            if (view) {
                editingViewId = currentViewId;
                document.getElementById('viewTitleInput').value = view.title;
                document.getElementById('viewDescriptionInput').value = view.description;
                document.getElementById('viewType').value = view.type;
                document.getElementById('newViewModal').style.display = 'block';
            }
        }

        function deleteCurrentView() {
            if (currentViewId === 'default') {
                alert('Impossible de supprimer la vue par défaut');
                return;
            }

            if (confirm('Supprimer cette vue et tous ses flux ?')) {
                appData.customViews = appData.customViews.filter(v => v.id !== currentViewId);
                appData.networkFlows = appData.networkFlows.filter(f => f.viewId !== currentViewId);
                currentViewId = 'default';
                appData.metadata.lastModified = new Date().toISOString();
                updateViewSelector();
                updateDisplay();
                saveToStorage();
            }
        }

        function updateViewSelector() {
            const selector = document.getElementById('cartographyType');
            selector.innerHTML = '<option value="default">Vue par défaut</option>';
            
            appData.customViews.forEach(view => {
                const option = document.createElement('option');
                option.value = view.id;
                option.textContent = view.title;
                selector.appendChild(option);
            });

            selector.value = currentViewId;
        }

        function changeCartographyType() {
            currentViewId = document.getElementById('cartographyType').value;
            updateDisplay();
            saveToStorage();
        }

        function getCurrentView() {
            if (currentViewId === 'default') {
                return { title: 'Vue par défaut', description: 'Cartographie générale', type: 'vertical' };
            }
            return appData.customViews.find(v => v.id === currentViewId) || { title: 'Vue inconnue', description: '', type: 'vertical' };
        }

        function getCurrentFlows() {
            if (currentViewId === 'default') {
                return appData.networkFlows.filter(flow => flow.viewId === 'default');
            } else {
                // Pour les autres vues : flux par défaut + modifications de cette vue
                const defaultFlows = appData.networkFlows.filter(flow => flow.viewId === 'default');
                const viewModifications = appData.networkFlows.filter(flow => flow.viewId === currentViewId);
                
                let finalFlows = [];
                
                // Ajouter les flux par défaut qui ne sont pas annulés ou remplacés
                defaultFlows.forEach(defaultFlow => {
                    const isCancelled = viewModifications.some(mod => 
                        mod.variantType === 'cancellation' && mod.cancelledFlowId == defaultFlow.id
                    );
                    const isReplaced = viewModifications.some(mod => 
                        mod.variantType === 'replacement' && mod.replacedFlowId == defaultFlow.id
                    );
                    
                    if (!isCancelled && !isReplaced) {
                        finalFlows.push(defaultFlow);
                    }
                });
                
                // Ajouter les flux de remplacement et spécifiques
                viewModifications.forEach(mod => {
                    if (mod.variantType === 'replacement' || mod.variantType === 'addition') {
                        finalFlows.push(mod);
                    }
                });
                
                return finalFlows;
            }
        }

        // Mise à jour de l'affichage
        function updateDisplay() {
            const currentView = getCurrentView();
            document.getElementById('viewTitle').textContent = currentView.title;
            document.getElementById('viewDescription').textContent = currentView.description;
            
            updateFlowList();
            updateStats();
            drawNetworkDiagram();
        }

        function updateFlowList() {
            const flowList = document.getElementById('flowList');
            const currentFlows = getCurrentFlows();
            flowList.innerHTML = '';

            currentFlows.forEach(flow => {
                const flowElement = document.createElement('div');
                flowElement.className = 'flow-item';
                
                const riskClass = `risk-${flow.riskLevel}`;
                const protocolClass = `protocol-${flow.protocol.toLowerCase()}`;
                
                let variantBadge = '';
                let variantInfo = '';
                
                if (flow.variantType) {
                    const badgeColors = {
                        'replacement': '#ff9800',
                        'addition': '#4caf50', 
                        'cancellation': '#f44336'
                    };
                    const badgeLabels = {
                        'replacement': 'REMPLACE',
                        'addition': 'AJOUTÉ',
                        'cancellation': 'ANNULÉ'
                    };
                    
                    variantBadge = `<span style="background: ${badgeColors[flow.variantType]}; color: white; padding: 2px 4px; border-radius: 8px; font-size: 8px; margin-left: 4px;">${badgeLabels[flow.variantType]}</span>`;
                    variantInfo = `<p><strong>Justification:</strong> <em>${flow.variantJustification}</em></p>`;
                }
                
                // Flux annulé (affichage spécial)
                if (flow.variantType === 'cancellation') {
                    const cancelledFlow = appData.networkFlows.find(f => f.id == flow.cancelledFlowId);
                    flowElement.innerHTML = `
                        <h4 style="text-decoration: line-through; opacity: 0.7;">${cancelledFlow ? cancelledFlow.name : 'Flux inconnu'}${variantBadge}</h4>
                        <p style="opacity: 0.7;"><span class="risk-indicator ${riskClass}"></span><span class="protocol-tag ${protocolClass}">${cancelledFlow ? cancelledFlow.protocol : 'N/A'}</span></p>
                        <p style="opacity: 0.7;"><strong>Flux annulé de la vue par défaut</strong></p>
                        ${variantInfo}
                        <div style="float: right; margin-top: 3px;">
                            <button onclick="editFlow(${flow.id})" style="background: #4caf50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 4px; font-size: 10px;">✏️</button>
                            <button onclick="deleteFlow(${flow.id})" style="background: #f44336; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">×</button>
                        </div>
                    `;
                } else {
                    flowElement.innerHTML = `
                        <h4>${flow.name}${variantBadge}</h4>
                        <p><span class="risk-indicator ${riskClass}"></span><span class="protocol-tag ${protocolClass}">${flow.protocol}</span></p>
                        <p><strong>Source:</strong> ${flow.sourceIP}:${flow.sourcePort || 'Auto'}</p>
                        <p><strong>Dest:</strong> ${flow.destIP}:${flow.destPort || 'Auto'}</p>
                        <p><strong>Risque:</strong> ${getRiskLabel(flow.riskLevel)}</p>
                        ${variantInfo}
                        <div style="float: right; margin-top: 3px;">
                            <button onclick="editFlow(${flow.id})" style="background: #4caf50; color: white; border: none; padding: 3px 8px; border-radius: 3px; cursor: pointer; margin-right: 4px; font-size: 10px;">✏️</button>
                            <button onclick="deleteFlow(${flow.id})" style="background: #f44336; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">×</button>
                        </div>
                    `;
                }
                
                flowList.appendChild(flowElement);
            });
        }

        function getRiskLabel(level) {
            const risk = appData.configData.riskLevels.find(r => r.value === level);
            return risk ? risk.label : level;
        }

        function updateStats() {
            const allFlows = appData.networkFlows;
            const criticalFlows = allFlows.filter(f => f.riskLevel === 'high' || f.riskLevel === 'critical');
            const variantFlows = allFlows.filter(f => f.variantType);
            
            document.getElementById('totalFlows').textContent = allFlows.length;
            document.getElementById('criticalFlows').textContent = criticalFlows.length;
            document.getElementById('totalViews').textContent = (appData.customViews.length + 1) + (variantFlows.length > 0 ? ` (${variantFlows.length}V)` : '');
        }

        // Cartographie
        function drawNetworkDiagram() {
            const svg = svgElement;
            svg.innerHTML = '';
            
            const width = svg.clientWidth || 800;
            const height = svg.clientHeight || 600;
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            const currentFlows = getCurrentFlows();
            if (currentFlows.length === 0) {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', width / 2);
                text.setAttribute('y', height / 2);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', 'rgba(255,255,255,0.7)');
                text.setAttribute('font-size', '16');
                text.textContent = 'Aucun flux dans cette vue. Ajoutez des flux pour voir la cartographie.';
                svg.appendChild(text);
                return;
            }

            const currentView = getCurrentView();
            if (currentView.type === 'server') {
                drawServerCartography(svg, width, height, currentFlows);
            } else {
                drawVerticalCartography(svg, width, height, currentFlows);
            }
        }

        function drawVerticalCartography(svg, width, height, flows) {
            // BPMN-style top-bottom flowchart with sources at bottom and destinations at top
            const laneHeight = height / 2;
            const margin = 80;
            const headerHeight = 60;
            const nodeSpacing = 140;
            
            // Calculate dynamic height based on number of flows for better spacing
            const numFlows = flows.length;
            const minHeight = 800;
            const dynamicHeight = Math.max(minHeight, numFlows * 40 + 400);
            
            // Update SVG height if needed for dynamic sizing
            if (dynamicHeight > height) {
                svg.setAttribute('height', dynamicHeight);
                height = dynamicHeight;
            }
            
            // Recalculate lane height with new dimensions
            const finalLaneHeight = height / 2;
            
            // Draw BPMN-style swimlanes background
            drawBPMNSwimlanes(svg, width, height, finalLaneHeight, headerHeight, 'vertical');
            
            // Get unique source and destination IPs
            const sourceIPs = getUniqueSourceIPs(flows);
            const destIPs = getUniqueDestIPs(flows);
            
            // Calculate proper horizontal positions for nodes with fixed spacing
            const availableWidth = width - margin * 2;
            const nodeWidth = 120; // Width of BPMN nodes
            const minSpacing = nodeWidth + 50; // Minimum space between node centers
            
            // Calculate actual spacing ensuring nodes don't overlap
            const sourceSpacing = sourceIPs.length > 1 ? Math.max(minSpacing, availableWidth / sourceIPs.length) : availableWidth / 2;
            const destSpacing = destIPs.length > 1 ? Math.max(minSpacing, availableWidth / destIPs.length) : availableWidth / 2;
            
            // Position source nodes at bottom with proper horizontal spacing
            const sourceNodes = new Map();
            sourceIPs.forEach((ip, index) => {
                const startX = margin + (sourceSpacing / 2);
                const x = startX + (index * sourceSpacing);
                sourceNodes.set(ip, {
                    ip: ip,
                    x: x,
                    y: height - finalLaneHeight + finalLaneHeight / 2, // Bottom lane center
                    connections: flows.filter(f => f.sourceIP === ip).length
                });
            });
            
            // Position destination nodes at top with proper horizontal spacing
            const destNodes = new Map();
            destIPs.forEach((ip, index) => {
                const startX = margin + (destSpacing / 2);
                const x = startX + (index * destSpacing);
                destNodes.set(ip, {
                    ip: ip,
                    x: x,
                    y: headerHeight + finalLaneHeight / 2, // Top lane center
                    connections: flows.filter(f => f.destIP === ip).length
                });
            });
            
            // Create arrow markers for BPMN-style flows
            createArrowMarkers(svg);
            
            // Draw dual T-junction system: Source T-junctions + Destination T-junctions
            drawDualTJunctionSystem(svg, sourceNodes, destNodes, flows, finalLaneHeight);

            // Draw source nodes (left lane)
            sourceNodes.forEach(node => {
                drawBPMNNode(svg, node, '#4caf50', 'source');
            });

            // Draw destination nodes (right lane)
            destNodes.forEach(node => {
                drawBPMNNode(svg, node, '#2196f3', 'destination');
            });
        }

        function drawBPMNSwimlanes(svg, width, height, laneHeight, headerHeight, orientation = 'horizontal') {
            // Draw BPMN-style swimlane background
            
            if (orientation === 'vertical') {
                // Vertical orientation: top lane for destinations, bottom lane for sources
                const midY = height / 2;
                
                // Lane separator line (horizontal)
                const separator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                separator.setAttribute('x1', 0);
                separator.setAttribute('y1', midY);
                separator.setAttribute('x2', width);
                separator.setAttribute('y2', midY);
                separator.setAttribute('stroke', '#ddd');
                separator.setAttribute('stroke-width', '2');
                separator.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(separator);
                
                // Top lane for destinations
                const topHeader = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                topHeader.setAttribute('x', 0);
                topHeader.setAttribute('y', 0);
                topHeader.setAttribute('width', width);
                topHeader.setAttribute('height', headerHeight);
                topHeader.setAttribute('fill', 'rgba(33, 150, 243, 0.1)');
                topHeader.setAttribute('stroke', '#2196f3');
                topHeader.setAttribute('stroke-width', '1');
                svg.appendChild(topHeader);
                
                // Bottom lane for sources
                const bottomHeader = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                bottomHeader.setAttribute('x', 0);
                bottomHeader.setAttribute('y', height - headerHeight);
                bottomHeader.setAttribute('width', width);
                bottomHeader.setAttribute('height', headerHeight);
                bottomHeader.setAttribute('fill', 'rgba(76, 175, 80, 0.1)');
                bottomHeader.setAttribute('stroke', '#4caf50');
                bottomHeader.setAttribute('stroke-width', '1');
                svg.appendChild(bottomHeader);
                
                // Lane titles
                const destTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                destTitle.setAttribute('x', width / 2);
                destTitle.setAttribute('y', headerHeight / 2 + 5);
                destTitle.setAttribute('text-anchor', 'middle');
                destTitle.setAttribute('fill', '#2196f3');
                destTitle.setAttribute('font-size', '16');
                destTitle.setAttribute('font-weight', 'bold');
                destTitle.textContent = '🎯 Destinations';
                svg.appendChild(destTitle);
                
                const sourceTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sourceTitle.setAttribute('x', width / 2);
                sourceTitle.setAttribute('y', height - headerHeight / 2 + 5);
                sourceTitle.setAttribute('text-anchor', 'middle');
                sourceTitle.setAttribute('fill', '#4caf50');
                sourceTitle.setAttribute('font-size', '16');
                sourceTitle.setAttribute('font-weight', 'bold');
                sourceTitle.textContent = '🖥️ Sources';
                svg.appendChild(sourceTitle);
                
            } else {
                // Original horizontal orientation
                const laneWidth = width / 2;
                
                // Lane separator line
                const separator = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                separator.setAttribute('x1', laneWidth);
                separator.setAttribute('y1', 0);
                separator.setAttribute('x2', laneWidth);
                separator.setAttribute('y2', height);
                separator.setAttribute('stroke', '#ddd');
                separator.setAttribute('stroke-width', '2');
                separator.setAttribute('stroke-dasharray', '5,5');
                svg.appendChild(separator);
                
                // Lane headers background
                const leftHeader = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                leftHeader.setAttribute('x', 0);
                leftHeader.setAttribute('y', 0);
                leftHeader.setAttribute('width', laneWidth);
                leftHeader.setAttribute('height', headerHeight);
                leftHeader.setAttribute('fill', 'rgba(76, 175, 80, 0.1)');
                leftHeader.setAttribute('stroke', '#4caf50');
                leftHeader.setAttribute('stroke-width', '1');
                svg.appendChild(leftHeader);
                
                const rightHeader = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rightHeader.setAttribute('x', laneWidth);
                rightHeader.setAttribute('y', 0);
                rightHeader.setAttribute('width', laneWidth);
                rightHeader.setAttribute('height', headerHeight);
                rightHeader.setAttribute('fill', 'rgba(33, 150, 243, 0.1)');
                rightHeader.setAttribute('stroke', '#2196f3');
                rightHeader.setAttribute('stroke-width', '1');
                svg.appendChild(rightHeader);
                
                // Lane titles
                const sourceTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sourceTitle.setAttribute('x', laneWidth / 2);
                sourceTitle.setAttribute('y', headerHeight / 2 + 5);
                sourceTitle.setAttribute('text-anchor', 'middle');
                sourceTitle.setAttribute('fill', '#4caf50');
                sourceTitle.setAttribute('font-size', '16');
                sourceTitle.setAttribute('font-weight', 'bold');
                sourceTitle.textContent = '🖥️ Sources';
                svg.appendChild(sourceTitle);
                
                const destTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                destTitle.setAttribute('x', laneWidth + (laneWidth / 2));
                destTitle.setAttribute('y', headerHeight / 2 + 5);
                destTitle.setAttribute('text-anchor', 'middle');
                destTitle.setAttribute('fill', '#2196f3');
                destTitle.setAttribute('font-size', '16');
                destTitle.setAttribute('font-weight', 'bold');
                destTitle.textContent = '🎯 Destinations';
                svg.appendChild(destTitle);
            }
        }

        function drawDualTJunctionSystem(svg, sourceNodes, destNodes, flows, laneHeight) {
            // Create comprehensive dual T-junction system showing ALL flows - vertical orientation
            
            const sourceTBusY = svg.getAttribute('height') - laneHeight / 2 - 80;  // Source T-junction bus position (horizontal line)
            const destTBusY = laneHeight / 2 + 80;  // Destination T-junction bus position (horizontal line)  
            const bridgeX = (Math.max(...Array.from(sourceNodes.values()).map(n => n.x)) + 
                           Math.max(...Array.from(destNodes.values()).map(n => n.x))) / 2; // Middle bridge level
            
            // Group flows by source for source T-junctions
            const flowsBySource = new Map();
            flows.forEach(flow => {
                if (!flowsBySource.has(flow.sourceIP)) {
                    flowsBySource.set(flow.sourceIP, []);
                }
                flowsBySource.get(flow.sourceIP).push(flow);
            });
            
            // Group flows by destination for destination T-junctions
            const flowsByDestination = new Map();
            flows.forEach(flow => {
                if (!flowsByDestination.has(flow.destIP)) {
                    flowsByDestination.set(flow.destIP, []);
                }
                flowsByDestination.get(flow.destIP).push(flow);
            });
            
            // Draw source-side T-junctions (vertical orientation)
            flowsBySource.forEach((sourceFlows, sourceIP) => {
                const sourceNode = sourceNodes.get(sourceIP);
                if (!sourceNode || sourceFlows.length === 0) return;
                
                drawVerticalSourceTJunction(svg, sourceNode, sourceFlows, sourceTBusY, bridgeX);
            });
            
            // Draw destination-side T-junctions (vertical orientation)
            flowsByDestination.forEach((destFlows, destIP) => {
                const destNode = destNodes.get(destIP);
                if (!destNode || destFlows.length === 0) return;
                
                drawVerticalDestinationTJunction(svg, destNode, destFlows, destTBusY, bridgeX);
            });
            
            // Draw individual flow bridges connecting source T to destination T (vertical)
            flows.forEach(flow => {
                drawVerticalFlowBridge(svg, flow, sourceTBusY, destTBusY, bridgeX);
            });
        }
        
        function drawSourceTJunction(svg, sourceNode, flows, tBusX, bridgeY) {
            // Calculate vertical extent for this source's T-junction
            const flowYPositions = flows.map((flow, index) => bridgeY + (index - flows.length/2) * 25);
            const minY = Math.min(sourceNode.y, ...flowYPositions);
            const maxY = Math.max(sourceNode.y, ...flowYPositions);
            
            // Main horizontal line from source node
            const sourceLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            sourceLine.setAttribute('x1', sourceNode.x + 60);
            sourceLine.setAttribute('y1', sourceNode.y);
            sourceLine.setAttribute('x2', tBusX);
            sourceLine.setAttribute('y2', sourceNode.y);
            sourceLine.setAttribute('stroke', '#4caf50');
            sourceLine.setAttribute('stroke-width', '3');
            svg.appendChild(sourceLine);
            
            // Vertical T-junction bus for this source
            const verticalBus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            verticalBus.setAttribute('x1', tBusX);
            verticalBus.setAttribute('y1', minY);
            verticalBus.setAttribute('x2', tBusX);
            verticalBus.setAttribute('y2', maxY);
            verticalBus.setAttribute('stroke', '#4caf50');
            verticalBus.setAttribute('stroke-width', '3');
            svg.appendChild(verticalBus);
            
            // Individual flow connections from T-junction
            flows.forEach((flow, index) => {
                const flowY = bridgeY + (index - (flows.length - 1) / 2) * 25;
                
                const riskColors = {
                    low: '#4caf50',
                    medium: '#ff9800',
                    high: '#f44336', 
                    critical: '#d32f2f'
                };
                
                const color = riskColors[flow.riskLevel] || '#666';
                const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
                
                // Horizontal line from T-junction to bridge area
                const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                flowLine.setAttribute('x1', tBusX);
                flowLine.setAttribute('y1', flowY);
                flowLine.setAttribute('x2', tBusX + 40);
                flowLine.setAttribute('y2', flowY);
                flowLine.setAttribute('stroke', color);
                flowLine.setAttribute('stroke-width', strokeWidth);
                svg.appendChild(flowLine);
                
                // Flow label
                const labelX = tBusX + 20;
                const labelY = flowY - 5;
                
                const labelText = `${flow.protocol}`;
                const portText = flow.destPort ? `:${flow.destPort}` : '';
                
                const protocolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                protocolLabel.setAttribute('x', labelX);
                protocolLabel.setAttribute('y', labelY);
                protocolLabel.setAttribute('text-anchor', 'middle');
                protocolLabel.setAttribute('fill', color);
                protocolLabel.setAttribute('font-size', '8');
                protocolLabel.setAttribute('font-weight', 'bold');
                protocolLabel.textContent = labelText + portText;
                svg.appendChild(protocolLabel);
            });
        }
        
        function drawDestinationTJunction(svg, destNode, flows, tBusX, bridgeY) {
            // Calculate vertical extent for this destination's T-junction
            const flowYPositions = flows.map((flow, index) => bridgeY + (index - flows.length/2) * 25);
            const minY = Math.min(destNode.y, ...flowYPositions);
            const maxY = Math.max(destNode.y, ...flowYPositions);
            
            // Vertical T-junction bus for this destination
            const verticalBus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            verticalBus.setAttribute('x1', tBusX);
            verticalBus.setAttribute('y1', minY);
            verticalBus.setAttribute('x2', tBusX);
            verticalBus.setAttribute('y2', maxY);
            verticalBus.setAttribute('stroke', '#2196f3');
            verticalBus.setAttribute('stroke-width', '3');
            svg.appendChild(verticalBus);
            
            // Main horizontal line to destination node
            const destLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            destLine.setAttribute('x1', tBusX);
            destLine.setAttribute('y1', destNode.y);
            destLine.setAttribute('x2', destNode.x - 60);
            destLine.setAttribute('y2', destNode.y);
            destLine.setAttribute('stroke', '#2196f3');
            destLine.setAttribute('stroke-width', '3');
            destLine.setAttribute('marker-end', 'url(#arrow-medium)');
            svg.appendChild(destLine);
            
            // Individual flow connections to T-junction
            flows.forEach((flow, index) => {
                const flowY = bridgeY + (index - (flows.length - 1) / 2) * 25;
                
                const riskColors = {
                    low: '#4caf50',
                    medium: '#ff9800',
                    high: '#f44336',
                    critical: '#d32f2f'
                };
                
                const color = riskColors[flow.riskLevel] || '#666';
                const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
                
                // Horizontal line from bridge area to T-junction
                const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                flowLine.setAttribute('x1', tBusX - 40);
                flowLine.setAttribute('y1', flowY);
                flowLine.setAttribute('x2', tBusX);
                flowLine.setAttribute('y2', flowY);
                flowLine.setAttribute('stroke', color);
                flowLine.setAttribute('stroke-width', strokeWidth);
                svg.appendChild(flowLine);
            });
        }
        
        function drawFlowBridge(svg, flow, sourceTBusX, destTBusX, bridgeY) {
            // Draw individual flow bridge connecting source T to destination T
            const riskColors = {
                low: '#4caf50',
                medium: '#ff9800',
                high: '#f44336',
                critical: '#d32f2f'
            };
            
            const color = riskColors[flow.riskLevel] || '#666';
            const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
            
            // Get flow positions (this needs to match the Y positions calculated in T-junction functions)
            // For now, use a simple offset system
            const flowIndex = Math.abs(flow.sourceIP.charCodeAt(flow.sourceIP.length-1) + 
                                     flow.destIP.charCodeAt(flow.destIP.length-1)) % 10;
            const flowY = bridgeY + (flowIndex - 5) * 25;
            
            // Horizontal bridge line
            const bridgeLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            bridgeLine.setAttribute('x1', sourceTBusX + 40);
            bridgeLine.setAttribute('y1', flowY);
            bridgeLine.setAttribute('x2', destTBusX - 40);
            bridgeLine.setAttribute('y2', flowY);
            bridgeLine.setAttribute('stroke', color);
            bridgeLine.setAttribute('stroke-width', strokeWidth);
            bridgeLine.setAttribute('stroke-dasharray', '5,3');
            svg.appendChild(bridgeLine);
        }

        function drawVerticalSourceTJunction(svg, sourceNode, flows, tBusY, bridgeX) {
            // Calculate horizontal extent for this source's T-junction (vertical orientation)
            const flowXPositions = flows.map((flow, index) => bridgeX + (index - flows.length/2) * 40);
            const minX = Math.min(sourceNode.x, ...flowXPositions);
            const maxX = Math.max(sourceNode.x, ...flowXPositions);
            
            // Main vertical line from source node upward
            const sourceLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            sourceLine.setAttribute('x1', sourceNode.x);
            sourceLine.setAttribute('y1', sourceNode.y - 30);
            sourceLine.setAttribute('x2', sourceNode.x);
            sourceLine.setAttribute('y2', tBusY);
            sourceLine.setAttribute('stroke', '#4caf50');
            sourceLine.setAttribute('stroke-width', '3');
            svg.appendChild(sourceLine);
            
            // Horizontal T-junction bus for this source
            const horizontalBus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            horizontalBus.setAttribute('x1', minX);
            horizontalBus.setAttribute('y1', tBusY);
            horizontalBus.setAttribute('x2', maxX);
            horizontalBus.setAttribute('y2', tBusY);
            horizontalBus.setAttribute('stroke', '#4caf50');
            horizontalBus.setAttribute('stroke-width', '3');
            svg.appendChild(horizontalBus);
            
            // Individual flow connections from T-junction
            flows.forEach((flow, index) => {
                const flowX = bridgeX + (index - (flows.length - 1) / 2) * 40;
                
                const riskColors = {
                    low: '#4caf50',
                    medium: '#ff9800',
                    high: '#f44336', 
                    critical: '#d32f2f'
                };
                
                const color = riskColors[flow.riskLevel] || '#666';
                const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
                
                // Vertical line from T-junction toward destination
                const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                flowLine.setAttribute('x1', flowX);
                flowLine.setAttribute('y1', tBusY);
                flowLine.setAttribute('x2', flowX);
                flowLine.setAttribute('y2', tBusY - 60);
                flowLine.setAttribute('stroke', color);
                flowLine.setAttribute('stroke-width', strokeWidth);
                svg.appendChild(flowLine);
            });
        }

        function drawVerticalDestinationTJunction(svg, destNode, flows, tBusY, bridgeX) {
            // Calculate horizontal extent for this destination's T-junction (vertical orientation)
            const flowXPositions = flows.map((flow, index) => bridgeX + (index - flows.length/2) * 40);
            const minX = Math.min(destNode.x, ...flowXPositions);
            const maxX = Math.max(destNode.x, ...flowXPositions);
            
            // Main vertical line from destination node downward
            const destLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            destLine.setAttribute('x1', destNode.x);
            destLine.setAttribute('y1', destNode.y + 30);
            destLine.setAttribute('x2', destNode.x);
            destLine.setAttribute('y2', tBusY);
            destLine.setAttribute('stroke', '#2196f3');
            destLine.setAttribute('stroke-width', '3');
            svg.appendChild(destLine);
            
            // Horizontal T-junction bus for this destination
            const horizontalBus = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            horizontalBus.setAttribute('x1', minX);
            horizontalBus.setAttribute('y1', tBusY);
            horizontalBus.setAttribute('x2', maxX);
            horizontalBus.setAttribute('y2', tBusY);
            horizontalBus.setAttribute('stroke', '#2196f3');
            horizontalBus.setAttribute('stroke-width', '3');
            svg.appendChild(horizontalBus);
            
            // Individual flow connections from T-junction
            flows.forEach((flow, index) => {
                const flowX = bridgeX + (index - (flows.length - 1) / 2) * 40;
                
                const riskColors = {
                    low: '#4caf50',
                    medium: '#ff9800',
                    high: '#f44336', 
                    critical: '#d32f2f'
                };
                
                const color = riskColors[flow.riskLevel] || '#666';
                const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
                
                // Vertical line from T-junction toward source  
                const flowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                flowLine.setAttribute('x1', flowX);
                flowLine.setAttribute('y1', tBusY);
                flowLine.setAttribute('x2', flowX);
                flowLine.setAttribute('y2', tBusY + 60);
                flowLine.setAttribute('stroke', color);
                flowLine.setAttribute('stroke-width', strokeWidth);
                flowLine.setAttribute('marker-end', `url(#arrow-${flow.riskLevel})`);
                svg.appendChild(flowLine);
            });
        }

        function drawVerticalFlowBridge(svg, flow, sourceTBusY, destTBusY, bridgeX) {
            // Draw individual flow bridge connecting source T to destination T (vertical)
            const riskColors = {
                low: '#4caf50',
                medium: '#ff9800',
                high: '#f44336',
                critical: '#d32f2f'
            };
            
            const color = riskColors[flow.riskLevel] || '#666';
            const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
            
            // Get flow positions (this needs to match the X positions calculated in T-junction functions)
            const flowIndex = Math.abs(flow.sourceIP.charCodeAt(flow.sourceIP.length-1) + 
                                     flow.destIP.charCodeAt(flow.destIP.length-1)) % 10;
            const flowX = bridgeX + (flowIndex - 5) * 40;
            
            // Vertical bridge line connecting source T to destination T
            const bridgeLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            bridgeLine.setAttribute('x1', flowX);
            bridgeLine.setAttribute('y1', sourceTBusY - 60);
            bridgeLine.setAttribute('x2', flowX);
            bridgeLine.setAttribute('y2', destTBusY + 60);
            bridgeLine.setAttribute('stroke', color);
            bridgeLine.setAttribute('stroke-width', strokeWidth);
            bridgeLine.setAttribute('stroke-dasharray', '8,4');
            bridgeLine.setAttribute('marker-end', `url(#arrow-${flow.riskLevel})`);
            svg.appendChild(bridgeLine);
        }

        function drawBPMNTJunctionConnection(svg, sourceNodes, destNode, flows, laneWidth) {
            // Create T-junction connection for multiple flows to same destination
            const destEntryX = destNode.x - 60; // Entry point to destination
            const junctionX = laneWidth - 40;   // T-junction vertical line position
            
            // Main vertical line (stem of the T) - positioned near lane boundary
            const minSourceY = Math.min(...flows.map(f => sourceNodes.get(f.sourceIP).y));
            const maxSourceY = Math.max(...flows.map(f => sourceNodes.get(f.sourceIP).y));
            
            // Calculate the full vertical extent including destination
            const allYPositions = [...flows.map(f => sourceNodes.get(f.sourceIP).y), destNode.y];
            const minY = Math.min(...allYPositions);
            const maxY = Math.max(...allYPositions);
            
            // Draw the main vertical line (T stem) covering all connection points
            const mainVerticalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            mainVerticalLine.setAttribute('x1', junctionX);
            mainVerticalLine.setAttribute('y1', minY);
            mainVerticalLine.setAttribute('x2', junctionX);
            mainVerticalLine.setAttribute('y2', maxY);
            mainVerticalLine.setAttribute('stroke', '#666');
            mainVerticalLine.setAttribute('stroke-width', '3');
            svg.appendChild(mainVerticalLine);
            
            // Draw horizontal connection from T-junction to destination
            const destConnectionLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            destConnectionLine.setAttribute('x1', junctionX);
            destConnectionLine.setAttribute('y1', destNode.y);
            destConnectionLine.setAttribute('x2', destEntryX);
            destConnectionLine.setAttribute('y2', destNode.y);
            destConnectionLine.setAttribute('stroke', '#666');
            destConnectionLine.setAttribute('stroke-width', '2');
            svg.appendChild(destConnectionLine);
            
            // Final connection to destination node
            const finalLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            finalLine.setAttribute('x1', destEntryX);
            finalLine.setAttribute('y1', destNode.y);
            finalLine.setAttribute('x2', destNode.x - 30);
            finalLine.setAttribute('y2', destNode.y);
            finalLine.setAttribute('stroke', '#2196f3');
            finalLine.setAttribute('stroke-width', '3');
            finalLine.setAttribute('marker-end', 'url(#arrow-medium)');
            svg.appendChild(finalLine);
            
            // Draw individual source connections to the T-junction
            flows.forEach((flow, index) => {
                const sourceNode = sourceNodes.get(flow.sourceIP);
                if (!sourceNode) return;
                
                const riskColors = {
                    low: '#4caf50',
                    medium: '#ff9800', 
                    high: '#f44336',
                    critical: '#d32f2f'
                };
                
                const color = riskColors[flow.riskLevel] || '#666';
                const strokeWidth = flow.riskLevel === 'critical' ? 3 : flow.riskLevel === 'high' ? 2 : 1;
                
                // Horizontal line from source to T-junction
                const sourceLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                sourceLine.setAttribute('x1', sourceNode.x + 60);
                sourceLine.setAttribute('y1', sourceNode.y);
                sourceLine.setAttribute('x2', junctionX);
                sourceLine.setAttribute('y2', sourceNode.y);
                sourceLine.setAttribute('stroke', color);
                sourceLine.setAttribute('stroke-width', strokeWidth);
                svg.appendChild(sourceLine);
                
                // Add flow label
                const labelX = (sourceNode.x + 60 + junctionX) / 2;
                const labelY = sourceNode.y - 10;
                
                const labelText = `${flow.protocol}`;
                const portText = flow.destPort ? `:${flow.destPort}` : '';
                
                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textWidth = labelText.length * 6 + portText.length * 4;
                labelBg.setAttribute('x', labelX - textWidth/2 - 2);
                labelBg.setAttribute('y', labelY - 6);
                labelBg.setAttribute('width', textWidth + 4);
                labelBg.setAttribute('height', 12);
                labelBg.setAttribute('fill', 'rgba(255,255,255,0.9)');
                labelBg.setAttribute('stroke', color);
                labelBg.setAttribute('rx', '2');
                svg.appendChild(labelBg);
                
                const protocolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                protocolLabel.setAttribute('x', labelX);
                protocolLabel.setAttribute('y', labelY + 2);
                protocolLabel.setAttribute('text-anchor', 'middle');
                protocolLabel.setAttribute('fill', color);
                protocolLabel.setAttribute('font-size', '9');
                protocolLabel.setAttribute('font-weight', 'bold');
                protocolLabel.textContent = labelText + portText;
                svg.appendChild(protocolLabel);
            });
        }

        function drawBPMNFlowConnection(svg, source, dest, flow, laneWidth) {
            const riskColors = {
                low: '#4caf50',
                medium: '#ff9800', 
                high: '#f44336',
                critical: '#d32f2f'
            };
            
            const color = riskColors[flow.riskLevel] || '#666';
            const strokeWidth = flow.riskLevel === 'critical' ? 4 : flow.riskLevel === 'high' ? 3 : 2;
            
            // BPMN-style horizontal connection across lanes
            const sourceExitX = source.x + 60; // Exit point from source node
            const destEntryX = dest.x - 60;    // Entry point to destination node
            const connectionY = (source.y + dest.y) / 2; // Midpoint for horizontal bridge
            
            // Connection path: source -> exit horizontally -> bridge vertically -> entry horizontally -> destination
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            
            const pathData = `
                M ${source.x + 30} ${source.y}
                L ${sourceExitX} ${source.y}
                L ${sourceExitX} ${connectionY}
                L ${destEntryX} ${connectionY}
                L ${destEntryX} ${dest.y}
                L ${dest.x - 30} ${dest.y}
            `;
            
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', color);
            path.setAttribute('stroke-width', strokeWidth);
            path.setAttribute('fill', 'none');
            path.setAttribute('marker-end', `url(#arrow-${flow.riskLevel})`);
            svg.appendChild(path);
            
            // Add protocol label on the horizontal bridge
            const labelX = (sourceExitX + destEntryX) / 2;
            const labelY = connectionY;
            
            const labelText = `${flow.protocol}`;
            const portText = flow.destPort ? `:${flow.destPort}` : '';
            
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = labelText.length * 7 + portText.length * 5;
            labelBg.setAttribute('x', labelX - textWidth/2 - 3);
            labelBg.setAttribute('y', labelY - 8);
            labelBg.setAttribute('width', textWidth + 6);
            labelBg.setAttribute('height', 16);
            labelBg.setAttribute('fill', 'rgba(255,255,255,0.95)');
            labelBg.setAttribute('stroke', color);
            labelBg.setAttribute('rx', '3');
            svg.appendChild(labelBg);
            
            const protocolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            protocolLabel.setAttribute('x', labelX);
            protocolLabel.setAttribute('y', labelY + 4);
            protocolLabel.setAttribute('text-anchor', 'middle');
            protocolLabel.setAttribute('fill', color);
            protocolLabel.setAttribute('font-size', '12');
            protocolLabel.setAttribute('font-weight', 'bold');
            protocolLabel.textContent = labelText + portText;
            svg.appendChild(protocolLabel);
        }

        function drawBPMNNode(svg, node, color, type) {
            // BPMN-style rounded rectangle nodes
            const width = 120;
            const height = 60;
            
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.style.cursor = 'pointer';
            g.setAttribute('data-clickable', 'true');
            g.setAttribute('data-type', type);
            
            // Main node rectangle with BPMN styling
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', node.x - width/2);
            rect.setAttribute('y', node.y - height/2);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('rx', '10');
            rect.setAttribute('ry', '10');
            rect.setAttribute('fill', 'rgba(255,255,255,0.95)');
            rect.setAttribute('stroke', color);
            rect.setAttribute('stroke-width', '2');
            rect.setAttribute('filter', 'drop-shadow(2px 2px 4px rgba(0,0,0,0.1))');
            g.appendChild(rect);
            
            // Node text
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 5);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', color);
            text.setAttribute('font-size', '12');
            text.setAttribute('font-weight', 'bold');
            text.textContent = node.ip;
            g.appendChild(text);
            
            // Connection count badge
            if (node.connections > 0) {
                const badge = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                badge.setAttribute('cx', node.x + width/2 - 10);
                badge.setAttribute('cy', node.y - height/2 + 10);
                badge.setAttribute('r', '10');
                badge.setAttribute('fill', color);
                g.appendChild(badge);
                
                const badgeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                badgeText.setAttribute('x', node.x + width/2 - 10);
                badgeText.setAttribute('y', node.y - height/2 + 14);
                badgeText.setAttribute('text-anchor', 'middle');
                badgeText.setAttribute('fill', 'white');
                badgeText.setAttribute('font-size', '10');
                badgeText.setAttribute('font-weight', 'bold');
                badgeText.textContent = node.connections;
                g.appendChild(badgeText);
            }
            
            svg.appendChild(g);
        }

        function drawServerCartography(svg, width, height, flows) {
            const serverGroups = new Map();
            flows.forEach(flow => {
                if (!serverGroups.has(flow.sourceIP)) {
                    serverGroups.set(flow.sourceIP, []);
                }
                if (!serverGroups.has(flow.destIP)) {
                    serverGroups.set(flow.destIP, []);
                }
                serverGroups.get(flow.sourceIP).push(flow);
                if (flow.sourceIP !== flow.destIP) {
                    serverGroups.get(flow.destIP).push(flow);
                }
            });

            const nodes = new Map();
            let serverIndex = 0;
            const serverWidth = width / Math.max(1, serverGroups.size);

            serverGroups.forEach((serverFlows, serverIP) => {
                const serverX = serverIndex * serverWidth + serverWidth / 2;
                
                if (!nodes.has(serverIP)) {
                    nodes.set(serverIP, {
                        ip: serverIP,
                        x: serverX,
                        y: height / 2,
                        connections: serverFlows.length,
                        isServer: true
                    });
                }
                
                serverFlows.forEach((flow, flowIndex) => {
                    const otherIP = flow.sourceIP === serverIP ? flow.destIP : flow.sourceIP;
                    if (!nodes.has(otherIP)) {
                        const angle = (flowIndex / serverFlows.length) * 2 * Math.PI;
                        const radius = 100;
                        nodes.set(otherIP, {
                            ip: otherIP,
                            x: serverX + Math.cos(angle) * radius,
                            y: height / 2 + Math.sin(angle) * radius,
                            connections: 1,
                            isServer: false
                        });
                    }
                });
                serverIndex++;
            });

            createArrowMarkers(svg);
            
            flows.forEach(flow => {
                const source = nodes.get(flow.sourceIP);
                const dest = nodes.get(flow.destIP);
                if (source && dest) {
                    drawFlowArrow(svg, source, dest, flow);
                }
            });

            nodes.forEach(node => {
                const color = node.isServer ? '#ff6b6b' : '#36d1dc';
                drawNode(svg, node, color, node.isServer ? 'Serveur' : 'Client');
            });
        }

        function createArrowMarkers(svg) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            ['low', 'medium', 'high', 'critical'].forEach(risk => {
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
                marker.setAttribute('id', `arrow-${risk}`);
                marker.setAttribute('markerWidth', '10');
                marker.setAttribute('markerHeight', '10');
                marker.setAttribute('refX', '8');
                marker.setAttribute('refY', '3');
                marker.setAttribute('orient', 'auto');
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', '0 0, 10 3, 0 6');
                
                const colors = {
                    low: '#4caf50',
                    medium: '#ff9800',
                    high: '#f44336',
                    critical: '#d32f2f'
                };
                
                polygon.setAttribute('fill', colors[risk]);
                marker.appendChild(polygon);
                defs.appendChild(marker);
            });
            
            svg.appendChild(defs);
        }

        function drawFlowArrow(svg, source, dest, flow) {
            const riskColors = {
                low: '#4caf50',
                medium: '#ff9800',
                high: '#f44336',
                critical: '#d32f2f'
            };
            
            const color = riskColors[flow.riskLevel] || '#666';
            const strokeWidth = flow.riskLevel === 'critical' ? 4 : flow.riskLevel === 'high' ? 3 : 2;
            
            // Create double T-style connection for professional network diagram look
            // Calculate connection points for better routing
            const sourceExtendDistance = 60; // Distance to extend from source
            const destExtendDistance = 60;   // Distance to extend from destination
            
            // Key junction points
            const sourceJunctionX = source.x + sourceExtendDistance;
            const destJunctionX = dest.x - destExtendDistance;
            const midY = (source.y + dest.y) / 2; // Horizontal bus level
            
            // Line 1: Horizontal extension from source (first part of first T)
            const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line1.setAttribute('x1', source.x);
            line1.setAttribute('y1', source.y);
            line1.setAttribute('x2', sourceJunctionX);
            line1.setAttribute('y2', source.y);
            line1.setAttribute('stroke', color);
            line1.setAttribute('stroke-width', strokeWidth);
            svg.appendChild(line1);
            
            // Line 2: Vertical from source level to bus level (vertical part of first T)
            const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line2.setAttribute('x1', sourceJunctionX);
            line2.setAttribute('y1', source.y);
            line2.setAttribute('x2', sourceJunctionX);
            line2.setAttribute('y2', midY);
            line2.setAttribute('stroke', color);
            line2.setAttribute('stroke-width', strokeWidth);
            svg.appendChild(line2);
            
            // Line 3: Horizontal bus line connecting the two T-junctions
            const line3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line3.setAttribute('x1', sourceJunctionX);
            line3.setAttribute('y1', midY);
            line3.setAttribute('x2', destJunctionX);
            line3.setAttribute('y2', midY);
            line3.setAttribute('stroke', color);
            line3.setAttribute('stroke-width', strokeWidth);
            svg.appendChild(line3);
            
            // Line 4: Vertical from bus level to destination level (vertical part of second T)
            const line4 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line4.setAttribute('x1', destJunctionX);
            line4.setAttribute('y1', midY);
            line4.setAttribute('x2', destJunctionX);
            line4.setAttribute('y2', dest.y);
            line4.setAttribute('stroke', color);
            line4.setAttribute('stroke-width', strokeWidth);
            svg.appendChild(line4);
            
            // Line 5: Final horizontal to destination with arrow (second part of second T)
            const line5 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line5.setAttribute('x1', destJunctionX);
            line5.setAttribute('y1', dest.y);
            line5.setAttribute('x2', dest.x);
            line5.setAttribute('y2', dest.y);
            line5.setAttribute('stroke', color);
            line5.setAttribute('stroke-width', strokeWidth);
            line5.setAttribute('marker-end', `url(#arrow-${flow.riskLevel})`);
            svg.appendChild(line5);

            // Calculate best position for label (on the horizontal bus line)
            const labelX = (sourceJunctionX + destJunctionX) / 2;
            const labelY = midY;
            
            const labelText = `${flow.protocol}`;
            const portText = flow.destPort ? `:${flow.destPort}` : '';
            
            // Position label on the horizontal bus line between the T-junctions
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const textWidth = labelText.length * 7 + portText.length * 5;
            labelBg.setAttribute('x', labelX - textWidth/2 - 3);
            labelBg.setAttribute('y', labelY - 6);
            labelBg.setAttribute('width', textWidth + 6);
            labelBg.setAttribute('height', 12);
            labelBg.setAttribute('fill', 'rgba(255,255,255,0.95)');
            labelBg.setAttribute('stroke', color);
            labelBg.setAttribute('rx', '3');
            svg.appendChild(labelBg);
            
            const protocolLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            protocolLabel.setAttribute('x', labelX);
            protocolLabel.setAttribute('y', labelY + 3);
            protocolLabel.setAttribute('text-anchor', 'middle');
            protocolLabel.setAttribute('fill', color);
            protocolLabel.setAttribute('font-size', '10');
            protocolLabel.setAttribute('font-weight', 'bold');
            protocolLabel.textContent = labelText + portText;
            svg.appendChild(protocolLabel);
        }

        function drawNode(svg, node, color, type) {
            // Calculer la taille en fonction de la longueur du texte
            const textLength = node.ip.length;
            const minRadius = 25;
            const radiusPerChar = 4;
            const nodeSize = Math.max(minRadius, textLength * radiusPerChar);
            
            // Créer un groupe pour le noeud
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.style.cursor = 'pointer';
            g.setAttribute('class', 'network-node');
            g.setAttribute('data-ip', node.ip);
            g.setAttribute('data-type', type);
            
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            circle.setAttribute('cx', node.x);
            circle.setAttribute('cy', node.y);
            circle.setAttribute('rx', nodeSize);
            circle.setAttribute('ry', Math.max(20, nodeSize * 0.6));
            circle.setAttribute('fill', 'rgba(255,255,255,0.95)');
            circle.setAttribute('stroke', color);
            circle.setAttribute('stroke-width', '2');
            g.appendChild(circle);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', node.x);
            text.setAttribute('y', node.y + 3);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', '#333');
            text.setAttribute('font-size', Math.max(8, Math.min(11, 60 / textLength)));
            text.setAttribute('font-weight', 'bold');
            text.textContent = node.ip;
            g.appendChild(text);

            // Ajouter le gestionnaire de clic pour le menu contextuel
            g.addEventListener('click', function(e) {
                e.stopPropagation();
                showNodeContextMenu(e, node, type);
            });

            // Effet hover
            g.addEventListener('mouseenter', function() {
                circle.setAttribute('stroke-width', '3');
                circle.setAttribute('fill', 'rgba(255,255,255,1)');
            });
            
            g.addEventListener('mouseleave', function() {
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('fill', 'rgba(255,255,255,0.95)');
            });
            
            svg.appendChild(g);
        }

        function getUniqueSourceIPs(flows) {
            return [...new Set(flows.map(flow => flow.sourceIP))];
        }

        function getUniqueDestIPs(flows) {
            return [...new Set(flows.map(flow => flow.destIP))];
        }

        // Configuration
        function saveConfiguration() {
            try {
                appData.configData.protocols = JSON.parse(document.getElementById('protocolsConfig').value);
                appData.configData.riskLevels = JSON.parse(document.getElementById('riskLevelsConfig').value);
                appData.configData.commonPorts = JSON.parse(document.getElementById('portsConfig').value);
                
                appData.metadata.lastModified = new Date().toISOString();
                populateDropdowns();
                saveToStorage();
                closeConfigModal();
                alert('Configuration sauvegardée!');
            } catch (error) {
                alert('Erreur JSON: ' + error.message);
            }
        }

        function resetConfiguration() {
            appData.configData = {
                protocols: [
                    { value: 'TCP', label: 'TCP' },
                    { value: 'UDP', label: 'UDP' },
                    { value: 'HTTP', label: 'HTTP' },
                    { value: 'HTTPS', label: 'HTTPS' },
                    { value: 'ICMP', label: 'ICMP' },
                    { value: 'SSH', label: 'SSH' },
                    { value: 'FTP', label: 'FTP' },
                    { value: 'SMTP', label: 'SMTP' },
                    { value: 'DNS', label: 'DNS' },
                    { value: 'SNMP', label: 'SNMP' },
                    { value: 'LDAP', label: 'LDAP' }
                ],
                riskLevels: [
                    { value: 'low', label: 'Faible' },
                    { value: 'medium', label: 'Moyen' },
                    { value: 'high', label: 'Élevé' },
                    { value: 'critical', label: 'Critique' }
                ],
                commonPorts: {
                    'HTTP': 80,
                    'HTTPS': 443,
                    'SSH': 22,
                    'FTP': 21,
                    'SMTP': 25,
                    'DNS': 53,
                    'SNMP': 161,
                    'LDAP': 389,
                    'TCP': 8080,
                    'UDP': 8080
                }
            };
            
            populateDropdowns();
            openConfigModal();
        }

        // Exemples
        function createDefaultCartography() {
            if (appData.networkFlows.length === 0) {
                const defaultFlows = [
                    {
                        id: Date.now() + 1,
                        viewId: 'default',
                        name: 'Utilisateurs vers Serveur Web',
                        protocol: 'HTTPS',
                        sourceIP: '10.0.1.100',
                        sourcePort: '',
                        destIP: '192.168.1.10',
                        destPort: '443',
                        riskLevel: 'low',
                        description: 'Trafic HTTPS des utilisateurs',
                        businessJustification: 'Accès sécurisé au portail web',
                        timestamp: new Date().toISOString()
                    },
                    {
                        id: Date.now() + 2,
                        viewId: 'default',
                        name: 'Serveur Web vers Base de données',
                        protocol: 'TCP',
                        sourceIP: '192.168.1.10',
                        sourcePort: '',
                        destIP: '192.168.1.20',
                        destPort: '3306',
                        riskLevel: 'medium',
                        description: 'Connexion base de données MySQL',
                        businessJustification: 'Requêtes applicatives',
                        timestamp: new Date().toISOString()
                    },
                    {
                        id: Date.now() + 3,
                        viewId: 'default',
                        name: 'Admin vers Serveur',
                        protocol: 'SSH',
                        sourceIP: '192.168.1.5',
                        sourcePort: '',
                        destIP: '192.168.1.10',
                        destPort: '22',
                        riskLevel: 'high',
                        description: 'Administration sécurisée',
                        businessJustification: 'Maintenance serveur',
                        timestamp: new Date().toISOString()
                    },
                    {
                        id: Date.now() + 4,
                        viewId: 'default',
                        name: 'Serveur vers DNS',
                        protocol: 'DNS',
                        sourceIP: '192.168.1.10',
                        sourcePort: '',
                        destIP: '8.8.8.8',
                        destPort: '53',
                        riskLevel: 'low',
                        description: 'Résolution DNS externe',
                        businessJustification: 'Résolution noms de domaine',
                        timestamp: new Date().toISOString()
                    }
                ];
                
                appData.networkFlows = defaultFlows;
                appData.metadata.lastModified = new Date().toISOString();
                updateDisplay();
                saveToStorage();
                alert('Cartographie d\'exemple créée!');
            } else {
                alert('Des flux existent déjà. Videz d\'abord.');
            }
        }

        // Rapports
        function generateAuditReport() {
            openAuditModal();
        }

        function generateFullAuditReport() {
            // Sauvegarder les infos d'audit
            appData.auditInfo = {
                companyName: document.getElementById('companyName').value,
                auditorName: document.getElementById('auditorName').value,
                auditDate: document.getElementById('auditDate').value,
                auditScope: document.getElementById('auditScope').value,
                auditObjective: document.getElementById('auditObjective').value,
                auditConclusion: document.getElementById('auditConclusion').value
            };

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            // En-tête
            doc.setFontSize(20);
            doc.text('RAPPORT D\'AUDIT ISO 27001', 105, 25, { align: 'center' });
            doc.text('Analyse des Flux Réseaux', 105, 35, { align: 'center' });

            // Informations générales
            doc.setFontSize(12);
            doc.text(`Entreprise: ${appData.auditInfo.companyName}`, 20, 55);
            doc.text(`Auditeur: ${appData.auditInfo.auditorName}`, 20, 65);
            doc.text(`Date: ${appData.auditInfo.auditDate}`, 20, 75);
            doc.text(`Périmètre: ${appData.auditInfo.auditScope}`, 20, 85);

            // Objectif
            doc.setFontSize(14);
            doc.text('OBJECTIF DE L\'AUDIT', 20, 105);
            doc.setFontSize(10);
            const objectiveLines = doc.splitTextToSize(appData.auditInfo.auditObjective, 170);
            doc.text(objectiveLines, 20, 115);

            // Statistiques
            let yPos = 135 + objectiveLines.length * 5;
            doc.setFontSize(14);
            doc.text('STATISTIQUES', 20, yPos);
            yPos += 10;

            doc.setFontSize(10);
            doc.text(`Nombre total de flux: ${appData.networkFlows.length}`, 20, yPos);
            doc.text(`Nombre de vues: ${appData.customViews.length + 1}`, 20, yPos + 8);
            doc.text(`Flux critiques: ${appData.networkFlows.filter(f => f.riskLevel === 'high' || f.riskLevel === 'critical').length}`, 20, yPos + 16);

            // Analyse par vue
            yPos += 30;
            doc.setFontSize(14);
            doc.text('ANALYSE PAR VUE', 20, yPos);
            yPos += 10;

            doc.setFontSize(10);
            const allViews = [{ id: 'default', title: 'Vue par défaut', description: 'Cartographie générale' }, ...appData.customViews];
            
            allViews.forEach(view => {
                if (yPos > 250) {
                    doc.addPage();
                    yPos = 20;
                }

                const viewFlows = appData.networkFlows.filter(f => f.viewId === view.id);
                const variantFlows = viewFlows.filter(f => f.isVariant);
                
                doc.text(`• ${view.title}: ${viewFlows.length} flux (${variantFlows.length} variants)`, 25, yPos);
                
                if (viewFlows.length > 0) {
                    const criticalCount = viewFlows.filter(f => f.riskLevel === 'high' || f.riskLevel === 'critical').length;
                    doc.text(`  - Flux critiques: ${criticalCount}`, 30, yPos + 6);
                    
                    const protocols = [...new Set(viewFlows.map(f => f.protocol))];
                    doc.text(`  - Protocoles: ${protocols.join(', ')}`, 30, yPos + 12);
                }
                yPos += 20;
            });

            // Tableau des éléments variants
            const allVariants = appData.networkFlows.filter(f => f.isVariant);
            if (allVariants.length > 0) {
                if (yPos > 200) {
                    doc.addPage();
                    yPos = 20;
                }

                yPos += 15;
                doc.setFontSize(14);
                doc.text('TABLEAU DES ÉLÉMENTS VARIANTS', 20, yPos);
                yPos += 15;

                // En-tête du tableau
                doc.setFontSize(9);
                doc.setFont(undefined, 'bold');
                doc.text('Vue', 20, yPos);
                doc.text('Flux', 50, yPos);
                doc.text('Protocole', 90, yPos);
                doc.text('Source → Destination', 115, yPos);
                doc.text('Justification', 160, yPos);
                
                // Ligne de séparation
                doc.line(20, yPos + 2, 190, yPos + 2);
                yPos += 8;

                doc.setFont(undefined, 'normal');
                allVariants.forEach((variant, index) => {
                    if (yPos > 270) {
                        doc.addPage();
                        yPos = 20;
                    }

                    const viewTitle = getViewTitle(variant.viewId);
                    const sourceDestText = `${variant.sourceIP}:${variant.sourcePort || 'A'} → ${variant.destIP}:${variant.destPort || 'A'}`;
                    
                    doc.setFontSize(7);
                    doc.text(viewTitle.substring(0, 12), 20, yPos);
                    doc.text(variant.name.substring(0, 20), 50, yPos);
                    doc.text(variant.protocol, 90, yPos);
                    doc.text(sourceDestText.substring(0, 25), 115, yPos);
                    
                    // Justification sur plusieurs lignes si nécessaire
                    const justificationLines = doc.splitTextToSize(variant.variantJustification, 30);
                    let justYPos = yPos;
                    justificationLines.slice(0, 2).forEach(line => {
                        doc.text(line, 160, justYPos);
                        justYPos += 4;
                    });
                    
                    yPos += Math.max(8, justificationLines.length * 4);
                    
                    // Ligne de séparation tous les 5 éléments
                    if ((index + 1) % 5 === 0 && index + 1 < allVariants.length) {
                        doc.line(20, yPos, 190, yPos);
                        yPos += 3;
                    }
                });
            }

            // Conclusion
            if (yPos > 220) {
                doc.addPage();
                yPos = 20;
            }

            yPos += 10;
            doc.setFontSize(14);
            doc.text('CONCLUSION', 20, yPos);
            yPos += 10;

            doc.setFontSize(10);
            const conclusionLines = doc.splitTextToSize(appData.auditInfo.auditConclusion, 170);
            doc.text(conclusionLines, 20, yPos);

            // Signature
            yPos += conclusionLines.length * 5 + 20;
            if (yPos > 250) {
                doc.addPage();
                yPos = 50;
            }

            doc.text('Signature de l\'auditeur:', 20, yPos);
            doc.text('Date:', 120, yPos);
            doc.line(20, yPos + 15, 80, yPos + 15);
            doc.line(120, yPos + 15, 180, yPos + 15);

            closeAuditModal();
            saveToStorage();
            doc.save('rapport-audit-iso27001.pdf');
        }

        function generateTechnicalReport() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            doc.setFontSize(16);
            doc.text('Rapport Technique - Flux Réseaux', 20, 20);

            doc.setFontSize(10);
            doc.text(`Date: ${new Date().toLocaleDateString('fr-FR')}`, 20, 35);
            doc.text(`Total flux: ${appData.networkFlows.length}`, 20, 43);
            doc.text(`Flux critiques: ${appData.networkFlows.filter(f => f.riskLevel === 'high' || f.riskLevel === 'critical').length}`, 20, 51);

            let yPos = 65;
            doc.setFontSize(12);
            doc.text('Détail des Flux:', 20, yPos);
            yPos += 8;

            appData.networkFlows.forEach((flow, index) => {
                if (yPos > 260) {
                    doc.addPage();
                    yPos = 20;
                }

                doc.setFontSize(8);
                doc.text(`${index + 1}. ${flow.name} (Vue: ${getViewTitle(flow.viewId)})`, 20, yPos);
                doc.text(`${flow.protocol} | ${getRiskLabel(flow.riskLevel)}`, 25, yPos + 5);
                doc.text(`${flow.sourceIP}:${flow.sourcePort || 'Auto'} → ${flow.destIP}:${flow.destPort || 'Auto'}`, 25, yPos + 10);
                if (flow.description) {
                    doc.text(`${flow.description}`, 25, yPos + 15);
                }
                yPos += 22;
            });

            doc.save('rapport-technique-flux.pdf');
        }

        function getViewTitle(viewId) {
            if (viewId === 'default') return 'Défaut';
            const view = appData.customViews.find(v => v.id === viewId);
            return view ? view.title : 'Inconnue';
        }

        // Export Draw.io
        function exportDrawIO() {
            const currentFlows = getCurrentFlows();
            if (currentFlows.length === 0) {
                alert('Aucun flux à exporter dans cette vue.');
                return;
            }

            const sources = getUniqueSourceIPs(currentFlows);
            const destinations = getUniqueDestIPs(currentFlows);
            
            let drawioXML = `<?xml version="1.0" encoding="UTF-8"?>
<mxfile host="app.diagrams.net" modified="${new Date().toISOString()}" version="22.1.11">
  <diagram id="network-flows" name="Flux Réseau">
    <mxGraphModel dx="1422" dy="755" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="1169" pageHeight="827">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
`;

            let cellId = 2;
            const nodePositions = new Map();
            
            // Sources (en bas)
            sources.forEach((sourceIP, index) => {
                const x = (index + 1) * 800 / (sources.length + 1);
                const y = 600;
                nodePositions.set(sourceIP, { id: cellId, x: x, y: y });
                
                drawioXML += `
        <mxCell id="${cellId}" value="${sourceIP}" style="ellipse;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="${x-40}" y="${y-20}" width="80" height="40" as="geometry" />
        </mxCell>`;
                cellId++;
            });
            
            // Destinations (en haut)
            destinations.forEach((destIP, index) => {
                const x = (index + 1) * 800 / (destinations.length + 1);
                const y = 100;
                nodePositions.set(destIP, { id: cellId, x: x, y: y });
                
                drawioXML += `
        <mxCell id="${cellId}" value="${destIP}" style="ellipse;whiteSpace=wrap;html=1;fillColor=#dae8fc;strokeColor=#6c8ebf;" vertex="1" parent="1">
          <mxGeometry x="${x-40}" y="${y-20}" width="80" height="40" as="geometry" />
        </mxCell>`;
                cellId++;
            });
            
            // Flux (flèches)
            currentFlows.forEach(flow => {
                const source = nodePositions.get(flow.sourceIP);
                const dest = nodePositions.get(flow.destIP);
                
                if (source && dest) {
                    const color = flow.riskLevel === 'critical' ? '#f8cecc' : 
                                 flow.riskLevel === 'high' ? '#fff2cc' : 
                                 flow.riskLevel === 'medium' ? '#e1d5e7' : '#d5e8d4';
                    
                    drawioXML += `
        <mxCell id="${cellId}" value="${flow.protocol}${flow.destPort ? ':' + flow.destPort : ''}" style="endArrow=classic;html=1;labelBackgroundColor=${color};" edge="1" parent="1" source="${source.id}" target="${dest.id}">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="${source.x}" y="${source.y}" as="sourcePoint" />
            <mxPoint x="${dest.x}" y="${dest.y}" as="targetPoint" />
          </mxGeometry>
        </mxCell>`;
                    cellId++;
                }
            });

            drawioXML += `
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>`;

            const blob = new Blob([drawioXML], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `flux-${getCurrentView().title.replace(/[^a-zA-Z0-9]/g, '_')}.drawio`;
            link.click();
            URL.revokeObjectURL(url);

            alert('Diagramme Draw.io exporté! Ouvrez le fichier dans https://app.diagrams.net/');
        }

        // Sauvegarde/Chargement
        function exportData() {
            appData.metadata.lastModified = new Date().toISOString();
            appData.metadata.exportDate = new Date().toISOString();
            
            const dataStr = JSON.stringify(appData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'audit-flux-reseaux-complet.json';
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData() {
            const file = document.getElementById('importFile').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const importedData = JSON.parse(e.target.result);
                        
                        // Validation de structure
                        if (importedData.networkFlows && Array.isArray(importedData.networkFlows)) {
                            appData.networkFlows = importedData.networkFlows;
                        }
                        
                        if (importedData.customViews && Array.isArray(importedData.customViews)) {
                            appData.customViews = importedData.customViews;
                        }
                        
                        if (importedData.configData) {
                            appData.configData = importedData.configData;
                        }
                        
                        if (importedData.auditInfo) {
                            appData.auditInfo = importedData.auditInfo;
                        }
                        
                        appData.metadata.lastModified = new Date().toISOString();
                        
                        populateDropdowns();
                        updateViewSelector();
                        updateDisplay();
                        saveToStorage();
                        alert('Données importées avec succès!');
                    } catch (error) {
                        alert('Erreur lors de l\'importation: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        function saveToStorage() {
            localStorage.setItem('auditFluxData', JSON.stringify(appData));
            localStorage.setItem('currentViewId', currentViewId);
        }

        function loadFromStorage() {
            const stored = localStorage.getItem('auditFluxData');
            if (stored) {
                try {
                    const loadedData = JSON.parse(stored);
                    
                    // Fusion intelligente des données
                    if (loadedData.networkFlows) appData.networkFlows = loadedData.networkFlows;
                    if (loadedData.customViews) appData.customViews = loadedData.customViews;
                    if (loadedData.configData) appData.configData = loadedData.configData;
                    if (loadedData.auditInfo) appData.auditInfo = loadedData.auditInfo;
                    if (loadedData.metadata) appData.metadata = loadedData.metadata;
                    
                    populateDropdowns();
                    updateViewSelector();
                    updateDisplay();
                } catch (error) {
                    console.error('Erreur chargement:', error);
                }
            }
            
            const storedViewId = localStorage.getItem('currentViewId');
            if (storedViewId) {
                currentViewId = storedViewId;
                document.getElementById('cartographyType').value = currentViewId;
            }
        }

        // Event listeners
        window.onclick = function(event) {
            const modals = ['flowModal', 'newViewModal', 'configModal', 'auditModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target === modal) {
                    modal.style.display = 'none';
                }
            });
        }

        window.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.style.display = 'none';
                });
            }
        });

        window.addEventListener('resize', function() {
            drawNetworkDiagram();
        });

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>